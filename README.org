#+TITLE: Emacs literate configuration
#+PROPERTY: header-args :tangle init.el
#+OPTIONS: toc:2 num:nil
#+auto_tangle: t
* Emacs configuration
After spending lot of time with doom emacs, willing to switch to a more native emacs config while keeping evil mode
* Header
Header for the config init.el file
#+begin_src emacs-lisp
  ;;; init.el --- Willydeliege's Emacs configuration -*- lexical-binding: t -*-

  ;; Copyright (C) 2023 Frédéric Willem

  ;; Author: Frédéric Willem <frederic.willem@gmail.com>
  ;; Keywords: internal

  ;;; Commentary:
  ;; A fully fledged, reproducible Emacs configuration

  ;;; Code:
#+end_src
* Package manager
Using [[https://github.com/radian-software/straight.el#getting-started][straight]] as package manager
#+begin_src emacs-lisp
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 6))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+end_src
** Using straight properly with initiating in early-init.el
This will prevent to use package.el
#+begin_src emacs-lisp :tangle early-init.el
  ;;; early-init.el --- Emacs early init file
  ;;; Commentary:
  ;; Code to run before init.el is loaded.
  ;;; Code:

  ;; Disable package.el
  (setq package-enable-at-startup nil)
  ;; start emacs window maximized
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
  (setq warning-minimum-level :emergency)
  ;;disable splash screen and startup message
  (setq inhibit-startup-message t)
  (setq initial-scratch-message nil)
  ;; trust the themes
  (setq custom-safe-themes t)
  (global-set-key (kbd "C-x c") 'save-buffers-kill-emacs)
  (setq backup-directory-alist `(("." . ,(expand-file-name "tmp/backups/" user-emacs-directory))))

  ;; auto-save-mode doesn't create the path automatically!
  (make-directory (expand-file-name "tmp/auto-saves/" user-emacs-directory) t)

  (setq auto-save-list-file-prefix (expand-file-name "tmp/auto-saves/sessions/" user-emacs-directory)
        auto-save-file-name-transforms `((".*" ,(expand-file-name "tmp/auto-saves/" user-emacs-directory) t)))

  (setq create-lockfiles nil)

  (provide 'early-init)
  ;;; early-init.el ends here
#+end_src
** USE-PACKAGE
We will use use-package
#+begin_src emacs-lisp
  (straight-use-package 'use-package)
#+end_src
and use straight by default
#+begin_src emacs-lisp
  (setq straight-use-package-by-default t)
#+end_src
* Defaults
#+begin_src emacs-lisp
  ;; Save the last place edited in files
  (save-place-mode 1)
  (setq save-place-file (locate-user-emacs-file "places" ".emacs-places"))
  (setq save-place-forget-unreadable-files nil)
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (recentf-mode 1)
  (setq recentf-max-menu-items 25)
  (setq recentf-max-saved-items 25)
  (setq display-line-numbers-type 'relative)
  (global-display-line-numbers-mode)
  (setq browse-url-browser-function 'browse-url-generic
      browse-url-generic-program "google-chrome")
#+end_src
** Help
Better help buffer
 #+begin_src emacs-lisp
   (use-package helpful
     :init
     (setq helpful--view-literal t)
     :config
     ;; Note that the built-in `describe-function' includes both functions
     ;; and macros. `helpful-function' is functions only, so we provide
     ;; `helpful-callable' as a drop-in replacement.
     (global-set-key (kbd "C-h f") #'helpful-callable)
     ;; Lookup the current symbol at point. C-c C-d is a common keybinding
     ;; for this in lisp modes.
     (global-set-key (kbd "C-c C-d") #'helpful-at-point)
     (global-set-key (kbd "C-h v") #'helpful-variable)
     (global-set-key (kbd "C-h k") #'helpful-key)
     (global-set-key (kbd "C-h x") #'helpful-command))
 #+end_src
* Personal information
#+begin_src emacs-lisp
  (setq user-full-name "Frédéric Willem"
        user-mail-address "frederic.willem@gmail.com")
#+end_src
* UI
** Theme
#+begin_src emacs-lisp
  (use-package modus-themes
    :config
    ;; Add all your customizations prior to loading the themes
    (setq modus-themes-italic-constructs t
          modus-themes-bold-constructs nil
          modus-themes-mixed-fonts t
          modus-themes-variable-pitch-ui nil
          modus-themes-custom-auto-reload t
          modus-themes-disable-other-themes t

          ;; Options for `modus-themes-prompts' are either nil (the
          ;; default), or a list of properties that may include any of those
          ;; symbols: `italic', `WEIGHT'
          modus-themes-prompts '(italic bold)

          ;; The `modus-themes-completions' is an alist that reads two
          ;; keys: `matches', `selection'.  Each accepts a nil value (or
          ;; empty list) or a list of properties that can include any of
          ;; the following (for WEIGHT read further below):
          ;;
          ;; `matches'   :: `underline', `italic', `WEIGHT'
          ;; `selection' :: `underline', `italic', `WEIGHT'
          modus-themes-completions
          '((matches . (extrabold))
            (selection . (semibold italic text-also)))

          modus-themes-org-blocks 'gray-background ; {nil,'gray-background,'tinted-background}

          ;; The `modus-themes-headings' is an alist: read the manual's
          ;; node about it or its doc string.  Basically, it supports
          ;; per-level configurations for the optional use of
          ;; `variable-pitch' typography, a height value as a multiple of
          ;; the base font size (e.g. 1.5), and a `WEIGHT'.
          modus-themes-headings
          '((agenda-date . (1.3))
            (agenda-structure . (variable-pitch light 1.8))
            (t . (1.1))))
    ;; Maybe define some palette overrides, such as by using our presets
    ;; (setq modus-themes-common-palette-overrides
    ;;       modus-themes-preset-overrides-intense)

    ;; Load the theme of your choice.
    (load-theme 'modus-vivendi))
  #+end_src
** Modeline
*** Nerd Icons
#+begin_src emacs-lisp
  (use-package nerd-icons
    ;; :custom
    ;; The Nerd Font you want to use in GUI
    ;; "Symbols Nerd Font Mono" is the default and is recommended
    ;; but you can use any other Nerd Font if you want
    ;; (nerd-icons-font-family "Symbols Nerd Font Mono")
    )
#+end_src
*** Doom-modeline
#+begin_src emacs-lisp
  (use-package doom-modeline
    :hook (after-init . doom-modeline-mode))
#+end_src
** Windos
#+begin_src emacs-lisp
  (use-package ace-window
    :bind ("M-o" . ace-window)
    :custom
    (aw-dispatch-always t))
#+end_src
* Editing
** Evil mode
Usage of evil mode as I used to work with vim binding for years
#+begin_src emacs-lisp
  (use-package undo-fu)

  (use-package evil
    :init
    (setq evil-want-integration t) ;; This is optional since it's already set to t by default.
    (setq evil-want-C-u-scroll t)
    (global-set-key (kbd "M-u") 'universal-argument)
    (define-key universal-argument-map (kbd "M-u") 'universal-argument-more)
    (setq evil-want-keybinding nil)
    (setq evil-undo-system 'undo-fu)
    :config
    (evil-mode 1))

  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init))
#+end_src
** Which-key
When you can't remember all keybindings
#+begin_src emacs-lisp
  (use-package which-key
    :after evil
    :init
    (which-key-setup-minibuffer)
    :hook (after-init . which-key-mode)
    :custom
    (which-key-allow-evil-operators t)
    (which-key-use-C-h-commands nil)
    (which-key-idle-delay 0.2))
#+end_src

** Parens
#+begin_src emacs-lisp
  (use-package electric-pair 
    :straight nil
    :init
    (electric-pair-mode 1))
  (use-package evil-surround
    :config
    (global-evil-surround-mode 1))
#+end_src
** Jump
#+begin_src emacs-lisp
  (use-package avy
    :demand t
    :config
    (global-set-key (kbd "C-c <SPC>") 'avy-goto-char-2))
#+end_src
** Evil commentary
#+begin_src emacs-lisp
  (use-package evil-commentary
    :init
    (evil-commentary-mode))
#+end_src
** evil search
#+begin_src emacs-lisp
  (use-package anzu
    :init
    (global-anzu-mode +1))
  (use-package evil-anzu :demand t)
#+end_src

#+RESULTS:

** evil org mode
#+begin_src emacs-lisp
  (use-package evil-org
    :after org
    :hook (org-mode . evil-org-mode)
    :config
    (evil-org-set-key-theme '(textobjects insert navigation additional shift todo heading))
    (require 'evil-org-agenda)
    (evil-org-agenda-set-keys))
#+end_src
* Completion
** Vertico + Marginalia
#+begin_src emacs-lisp
  (use-package vertico
    :bind (:map vertico-map
                ("C-j" . vertico-next)
                ("C-k" . vertico-previous)
                ("C-f" . vertico-exit)
                :map minibuffer-local-map
                ("C-h" . backward-kill-word))
    :custom
    (vertico-cycle t)
    :init
    (vertico-mode))

  (use-package savehist
    :init
    (savehist-mode))

  (use-package marginalia
    :after vertico
    :custom
    (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
    :init
    (marginalia-mode))
#+end_src
** Consult
#+begin_src emacs-lisp
  ;; Example configuration for Consult
  (use-package consult
    ;; Replace bindings. Lazily loaded due by `use-package'.
    :bind (;; C-c bindings in `mode-specific-map'
           ("C-c M-x" . consult-mode-command)
           ("C-c h" . consult-history)
           ("C-c k" . consult-kmacro)
           ;; ("C-c m" . consult-man)
           ("C-c i" . consult-info)
           ([remap Info-search] . consult-info)
           ;; C-x bindings in `ctl-x-map'
           ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
           ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
           ("C-x C-r" . consult-recent-file)        ;; orig. recent-files-read-only
           ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
           ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
           ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
           ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
           ;; Custom M-# bindings for fast register access
           ("M-#" . consult-register-load)
           ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
           ("C-M-#" . consult-register)
           ;; Other custom bindings
           ("M-y" . consult-yank-pop)                ;; orig. yank-pop
           ;; M-g bindings in `goto-map'
           ("M-g e" . consult-compile-error)
           ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
           ("M-g g" . consult-goto-line)             ;; orig. goto-line
           ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
           ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
           ("M-g m" . consult-mark)
           ("M-g k" . consult-global-mark)
           ("M-g i" . consult-imenu)
           ("M-g I" . consult-imenu-multi)
           ;; M-s bindings in `search-map'
           ("M-s d" . consult-find)
           ("M-s D" . consult-locate)
           ("M-s g" . consult-grep)
           ("M-s G" . consult-git-grep)
           ("M-s r" . consult-ripgrep)
           ("M-s l" . consult-line)
           ("M-s L" . consult-line-multi)
           ("M-s k" . consult-keep-lines)
           ("M-s u" . consult-focus-lines)
           ;; Isearch integration
           ("M-s e" . consult-isearch-history)
           :map isearch-mode-map
           ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
           ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
           ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
           ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
           ;; Minibuffer history
           :map minibuffer-local-map
           ("M-s" . consult-history)                 ;; orig. next-matching-history-element
           ("M-r" . consult-history))                ;; orig. previous-matching-history-element

    ;; Enable automatic preview at point in the *Completions* buffer. This is
    ;; relevant when you use the default completion UI.
    :hook (completion-list-mode . consult-preview-at-point-mode)

    ;; The :init configuration is always executed (Not lazy)
    :init

    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0.5
          register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    ;; Configure other variables and modes in the :config section,
    ;; after lazily loading the package.
    :config

    ;; Optionally configure preview. The default value
    ;; is 'any, such that any key triggers the preview.
    ;; (setq consult-preview-key 'any)
    (setq consult-preview-key "M-.")
    ;; (setq consult-preview-key '("S-<down>" "S-<up>"))
    ;; For some commands and buffer sources it is useful to configure the
    ;; :preview-key on a per-command basis using the `consult-customize' macro.
    ;; (consult-customize consult--source-buffer :hidden t :default nil)
    (consult-customize
     consult-theme :preview-key '(:debounce 0.2 any)
     consult-ripgrep consult-git-grep consult-grep
     consult-bookmark consult-recent-file consult-xref
     consult--source-bookmark consult--source-file-register
     consult--source-recent-file consult--source-project-recent-file
     ;; :preview-key "M-."
     :preview-key '(:debounce 0.4 any))

    ;; Optionally configure the narrowing key.
    ;; Both < and C-+ work reasonably well.
    (setq consult-narrow-key "<") ;; "C-+"

    ;; Optionally make narrowing help available in the minibuffer.
    ;; You may want to use `embark-prefix-help-command' or which-key instead.
    ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

    ;; By default `consult-project-function' uses `project-root' from project.el.
    ;; Optionally configure a different project root function.
    ;;;; 1. project.el (the default)
    ;; (setq consult-project-function #'consult--default-project--function)
    ;;;; 2. vc.el (vc-root-dir)
    ;; (setq consult-project-function (lambda (_) (vc-root-dir)))
    ;;;; 3. locate-dominating-file
    ;; (setq consult-project-function (lambda (_) (locate-dominating-file "." ".git")))
    ;;;; 4. projectile.el (projectile-project-root)
    (autoload 'projectile-project-root "projectile")
    (setq consult-project-function (lambda (_) (projectile-project-root)))
    ;;;; 5. No project support
    ;; (setq consult-project-function nil)
    )
#+end_src
*** Consult projectile
#+begin_src emacs-lisp
  (use-package consult-projectile
  :straight (consult-projectile :type git :host gitlab :repo "OlMon/consult-projectile" :branch "master"))
#+end_src
*** Consult org roam
#+begin_src emacs-lisp
  (use-package consult-org-roam
   :after org-roam
   :init
   (require 'consult-org-roam)
   ;; Activate the minor mode
   (consult-org-roam-mode 1)
   :custom
   ;; Use `ripgrep' for searching with `consult-org-roam-search'
   (consult-org-roam-grep-func #'consult-ripgrep)
   ;; Configure a custom narrow key for `consult-buffer'
   (consult-org-roam-buffer-narrow-key ?r)
   ;; Display org-roam buffers right after non-org-roam buffers
   ;; in consult-buffer (and not down at the bottom)
   (consult-org-roam-buffer-after-buffers t)
   :config
   ;; Eventually suppress previewing for certain functions
   (consult-customize
    consult-org-roam-forward-links
    :preview-key (kbd "C-;"))
   :bind
   ;; Define some convenient keybindings as an addition
   ("C-c n f" . consult-org-roam-file-find)
   ("C-c n b" . consult-org-roam-backlinks)
   ("C-c n l" . consult-org-roam-forward-links)
   ("C-c n r" . consult-org-roam-search))
#+end_src
** Embark
#+begin_src emacs-lisp
  (use-package embark
    :demand t ;; needed by eldoc otherwize eldoc error
    :bind
    (("C-h B" . embark-bindings) ;; alternative for `describe-bindings'
     (:map evil-normal-state-map
           ("C-." . embark-act)         ;; pick some comfortable binding
           ("M-." . embark-dwim)))        ;; good alternative: M-.
    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)

    ;; Show the Embark target at point via Eldoc.  You may adjust the Eldoc
    ;; strategy, if you want to see the documentation from multiple providers.
    (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
    ;; (setq eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)

    :config
    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none)))))

  ;; Consult users will also want the embark-consult package.
  (use-package embark-consult
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

** Orderless
#+begin_src emacs-lisp
  (use-package orderless
    :custom
    (completion-styles '(orderless flex))
    (orderless-matching-styles '(orderless-regexp orderless-flex)))
#+end_src
** Company
#+begin_src emacs-lisp
  (use-package company
    :hook ((prog-mode text-mode org-mode) . company-mode)

    :bind (:map company-active-map
                ("C-j" . company-select-next)
                ("C-k" . company-select-previous))
    :config
    ;; Add yasnippet support for all company backends
    ;; https://github.com/syl20bnr/spacemacs/pull/179
    (defvar company-mode/enable-yas t
      "Enable yasnippet for all backends.")

    (defun my/company-backend-with-yas (backend)
      (if (or (not company-mode/enable-yas) (and (listp backend) (member 'company-yasnippet backend)))
          backend
        (append (if (consp backend) backend (list backend))
                '(:with company-yasnippet))))

    (setq company-backends (mapcar #'my/company-backend-with-yas company-backends))
    (setq company-minimum-prefix-length 2)
    (setq company-idle-delay 0.3))
  ;; prettify completion styles
  (use-package company-box
    :hook (company-mode . company-box-mode))
#+end_src
** Snippets
#+begin_src emacs-lisp
  (use-package yasnippet
    :init
    (yas-global-mode 1))
  (use-package yasnippet-snippets
    :after yasnippet)
  (use-package doom-snippets
    :after yasnippet
    :straight (doom-snippets :type git :host github :repo "doomemacs/snippets" :files ("*.el" "*")))
#+end_src

* Projects
** Projectile
#+begin_src emacs-lisp
  (use-package projectile
    :hook (after-init . projectile-mode)
    :custom
    (projectile-switch-project-action 'projectile-commander)
    :bind (:map projectile-mode-map
                ("C-c p" . projectile-command-map)))
#+end_src

** Perspective
#+begin_src emacs-lisp
  (use-package perspective
    :hook (after-init . persp-mode)
    :bind
    ("C-x C-b" . persp-list-buffers)         ; or use a nicer switcher, see below
    :custom
    (persp-mode-prefix-key (kbd "C-c w")))  ; pick your own prefix key here
#+end_src

** Persp project
#+begin_src emacs-lisp
  (use-package persp-projectile)
#+end_src

* Org mode
** Org basics
#+begin_src emacs-lisp
  (use-package org
    :straight
    (:type built-in)
    :bind (("C-c a" . org-agenda))
    :hook ((org-mode . org-indent-mode))
    :config
    (setq org-agenda-files '("~/org/"))
    (setq org-stuck-projects '("+Project/PROJ" ("NEXT" "WAIT") nil ""))
    (setq org-todo-keywords
          '((sequence
             "TODO(t)"  ; A task that needs doing & is ready to do
             "NEXT(n)"  ; The nex task in to perform in the project
             "MEETING"  ; Meeting
             "PROJ(p)"  ; A project, which usually contains other tasks
             "WAIT(W@)"  ; Something external is holding up this task
             "HOLD(H@)"  ; This task is paused/on hold because of me
             "IDEA(i)"  ; An unconfirmed and unapproved task or notion
             "|"
             "DONE(d!)"  ; Task successfully completed
             "KILL(k)") ; Task was cancelled, aborted or is no longer applicable
            (sequence
             "[ ](T)"   ; A task that needs doing
             "[-](S)"   ; Task is in progress
             "|"
             "[X](D)")  ; Task was completed
            (sequence
             "READ(r)"
             "WATCH(w)"))))

#+end_src
** Org-agenda
#+begin_src emacs-lisp
  (use-package org-super-agenda
    :config
    (setq org-agenda-custom-commands
          '(("z" "My view"
             (   (agenda "" ((org-agenda-span 'day)
                             (org-agenda-start-day nil)
                             (org-super-agenda-groups
                              '((:name "Today"
                                       :time-grid t
                                       :date today
                                       :deadline today
                                       :scheduled today
                                       :order 1)))))
                 (alltodo "" ((org-agenda-overriding-header "")
                              (org-super-agenda-groups
                               '(;; Each group has an implicit boolean OR operator between its selectors.
                                 (:name "Today"
                                        :deadline today
                                        :face (:background "black"))
                                 (:name "Passed deadline"
                                        :and (:deadline past :todo ("TODO" "WAIT" "HOLD" "NEXT"))
                                        :face (:background "#7f1b19"))
                                 (:name "Important"
                                        :priority "A")
                                 (:priority<= "B"
                                              ;; Show this section after "Today" and "Important", because
                                              ;; their order is unspecified, defaulting to 0. Sections
                                              ;; are displayed lowest-number-first.
                                              :order 1)
                                 (:name "Next"
                                        :todo "NEXT"
                                        :order 8)
                                 (:name "Waiting"
                                        :todo "WAIT"
                                        :order 9)
                                 (:name "On hold"
                                        :todo "HOLD"
                                        :order 10)
                                 (:discard (:todo "PROJ"))))))))))
    (add-hook 'org-agenda-mode-hook 'org-super-agenda-mode))
#+end_src
** Org auto tangle
#+begin_src emacs-lisp
  (use-package org-auto-tangle
    :hook (org-mode . org-auto-tangle-mode))
#+end_src
** Org modern
Prettify org mode
#+begin_src emacs-lisp
  (use-package org-modern
    :after org
    :hook ((org-mode . org-modern-mode)
           (org-agenda-finalize . org-modern-agenda))
    :config
    (setq
     ;; Edit settings
     org-auto-align-tags nil
     org-tags-column 0
     org-catch-invisible-edits 'show-and-error
     org-special-ctrl-a/e t
     org-insert-heading-respect-content t

     ;; Org styling, hide markup etc.
     org-hide-emphasis-markers t
     org-pretty-entities t
     org-ellipsis "…"

     ;; Agenda styling
     org-agenda-tags-column 0
     org-agenda-block-separator ?─
     org-agenda-time-grid
     '((daily today require-timed)
       (800 1000 1200 1400 1600 1800 2000)
       " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄")
     org-agenda-current-time-string
     "⭠ now ─────────────────────────────────────────────────"))
#+end_src
** org roaom
#+begin_src emacs-lisp
  (use-package org-roam
    :ensure t
    :demand t  ;; Ensure org-roam is loaded by default
    :init
    (setq org-roam-v2-ack t)
    :custom
    (org-roam-directory "~/org")
    (org-roam-completion-everywhere t)
    :bind (("C-c n l" . org-roam-buffer-toggle)
           ("C-c n f" . org-roam-node-find)
           ("C-c n i" . org-roam-node-insert)
           ("C-c n I" . org-roam-node-insert-immediate)
           ("C-c n p" . my/org-roam-find-project)
           ("C-c n t" . my/org-roam-capture-task)
           ("C-c n b" . my/org-roam-capture-inbox)
           :map org-mode-map
           ("C-M-i" . completion-at-point)
           :map org-roam-dailies-map
           ("Y" . org-roam-dailies-capture-yesterday)
           ("T" . org-roam-dailies-capture-tomorrow))
    :bind-keymap
    ("C-c n d" . org-roam-dailies-map)
    :config
    (require 'org-roam-dailies) ;; Ensure the keymap is available
    (org-roam-db-autosync-mode))

  (defun org-roam-node-insert-immediate (arg &rest args)
    (interactive "P")
    (let ((args (push arg args))
          (org-roam-capture-templates (list (append (car org-roam-capture-templates)
                                                    '(:immediate-finish t)))))
      (apply #'org-roam-node-insert args)))

  (defun my/org-roam-filter-by-tag (tag-name)
    (lambda (node)
      (member tag-name (org-roam-node-tags node))))

  (defun my/org-roam-list-notes-by-tag (tag-name)
    (mapcar #'org-roam-node-file
            (seq-filter
             (my/org-roam-filter-by-tag tag-name)
             (org-roam-node-list))))

  (defun my/org-roam-refresh-agenda-list ()
    (interactive)
    (setq org-agenda-files (my/org-roam-list-notes-by-tag "Project")))

  ;; Build the agenda list the first time for the session
  (my/org-roam-refresh-agenda-list)

  (defun my/org-roam-project-finalize-hook ()
    "Adds the captured project file to `org-agenda-files' if the
    capture was not aborted."
    ;; Remove the hook since it was added temporarily
    (remove-hook 'org-capture-after-finalize-hook #'my/org-roam-project-finalize-hook)

    ;; Add project file to the agenda list if the capture was confirmed
    (unless org-note-abort
      (with-current-buffer (org-capture-get :buffer)
        (add-to-list 'org-agenda-files (buffer-file-name)))))

  (defun my/org-roam-find-project ()
    (interactive)
    ;; Add the project file to the agenda after capture is finished
    (add-hook 'org-capture-after-finalize-hook #'my/org-roam-project-finalize-hook)

    ;; Select a project file to open, creating it if necessary
    (org-roam-node-find
     nil
     nil
     (my/org-roam-filter-by-tag "Project")
     nil
     :templates
     '(("p" "project" plain "* Goals\n\n%?\n\n* Tasks\n\n** TODO Add initial tasks\n\n* Dates\n\n"
        :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+category: ${title}\n#+filetags: Project")
        :unnarrowed t))))

  (defun my/org-roam-capture-inbox ()
    (interactive)
    (org-roam-capture- :node (org-roam-node-create)
                       :templates '(("i" "inbox" plain "* %?"
                                     :if-new (file+head "Inbox.org" "#+title: Inbox\n")))))

  (defun my/org-roam-capture-task ()
    (interactive)
    ;; Add the project file to the agenda after capture is finished
    (add-hook 'org-capture-after-finalize-hook #'my/org-roam-project-finalize-hook)

    ;; Capture the new task, creating the project file if necessary
    (org-roam-capture- :node (org-roam-node-read
                              nil
                              (my/org-roam-filter-by-tag "Project"))
                       :templates '(("p" "project" plain "** TODO %?"
                                     :if-new (file+head+olp "%<%Y%m%d%H%M%S>-${slug}.org"
                                                            "#+title: ${title}\n#+category: ${title}\n#+filetags: Project"
                                                            ("Tasks"))))))

  (defun my/org-roam-copy-todo-to-today ()
    (interactive)
    (let ((org-refile-keep t) ;; Set this to nil to delete the original!
          (org-roam-dailies-capture-templates
           '(("t" "tasks" entry "%?"
              :if-new (file+head+olp "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n" ("Tasks")))))
          (org-after-refile-insert-hook #'save-buffer)
          today-file
          pos)
      (save-window-excursion
        (org-roam-dailies--capture (current-time) t)
        (setq today-file (buffer-file-name))
        (setq pos (point)))

      ;; Only refile if the target file is different than the current file
      (unless (equal (file-truename today-file)
                     (file-truename (buffer-file-name)))
        (org-refile nil nil (list "Tasks" today-file nil pos)))))

  (add-to-list 'org-after-todo-state-change-hook
               (lambda ()
                 (when (equal org-state "DONE")
                   (my/org-roam-copy-todo-to-today))))
		 #+end_src
* Mails
** Mu4e
#+begin_src emacs-lisp
  (use-package mu4e
    :demand t
    :straight '(mu4e :load-path  "/usr/local/share/emacs/site-lisp/mu4e/*.el")
    :bind (("<f5>" . mu4e))
    :config
    (setq mail-user-agent 'mu4e-user-agent)
    (setq mu4e-confirm-quit nil)
    (setq mu4e-get-mail-command "mbsync -a")
    (require 'mu4e-icalendar)
    (mu4e-icalendar-setup)
    (setq gnus-icalendar-org-capture-file "~/org/Inbox.org")
    (setq gnus-icalendar-org-capture-headline '("Calendar"))
    (gnus-icalendar-org-setup)
    (setq +org-capture-emails-file "Inbox.org")
    (setq mu4e-change-filenames-when-moving t)
    (setq sendmail-program (executable-find "msmtp")
          send-mail-function #'smtpmail-send-it
          message-sendmail-f-is-evil t
          message-sendmail-extra-arguments '("--read-envelope-from")
          message-send-mail-function #'message-send-mail-with-sendmail)
    ;; set a more visible mu4e view (with dark-mode enabled)
    (setq shr-color-visible-luminance-min 60)
    ;; use imagemagick, if available
    (when (fboundp 'imagemagick-register-types)
      (imagemagick-register-types))
    (setq mu4e-use-fancy-chars t)
    (setq
     mu4e-headers-draft-mark     '("D" . "💈")
     mu4e-headers-flagged-mark   '("F" . "📍")
     mu4e-headers-new-mark       '("N" . "🔥")
     mu4e-headers-passed-mark    '("P" . "❯")
     mu4e-headers-replied-mark   '("R" . "❮")
     mu4e-headers-seen-mark      '("S" . "☑")
     mu4e-headers-trashed-mark   '("T" . "💀")
     mu4e-headers-attach-mark    '("a" . "📎")
     mu4e-headers-encrypted-mark '("x" . "🔒")
     mu4e-headers-signed-mark    '("s" . "🔑")
     mu4e-headers-unread-mark    '("u" . "⎕")
     mu4e-headers-list-mark      '("l" . "🔈")
     mu4e-headers-personal-mark  '("p" . "👨")
     mu4e-headers-calendar-mark  '("c" . "📅"))
    (setq mu4e-update-interval 60)
    (setq mu4e-drafts-folder "/[Gmail]/Drafts")
    (setq mu4e-sent-folder   "/[Gmail]/Sent Mail")
    (setq mu4e-trash-folder  "/[Gmail]/Trash")
    (setq mu4e-maildir-shortcuts
          '( (:maildir "/INBOX" :key ?i)
             (:maildir "/[Gmail]/Sent Mail"  :key ?S)
             (:maildir "/[Gmail]/Trash" :key ?t)
             (:maildir "/[Gmail]/Starred" :key ?s)))

    (add-to-list 'org-capture-templates
                 '("m" "Email Workflow"))
    (add-to-list 'org-capture-templates
                 '("mf" "Follow Up" entry (file+olp "~/org/Inbox.org" "Follow Up")
                   "* TODO Follow up with %:fromname on %a\nSCHEDULED:%t\nDEADLINE: %(org-insert-time-stamp (org-read-date nil t \"+2d\"))\n\n%i" :immediate-finish t))
    (add-to-list 'org-capture-templates
                 '("mr" "Read Later" entry (file+olp "~/org/Inbox.org" "Read Later")
                   "* TODO Read %:subject\nSCHEDULED:%t\nDEADLINE: %(org-insert-time-stamp (org-read-date nil t \"+2d\"))\n\n%a\n\n%i" :immediate-finish t))

    (defun my/capture-mail-follow-up (msg)
      (interactive)
      (call-interactively 'org-store-link)
      (org-capture nil "mf"))

    (defun my/capture-mail-read-later (msg)
      (interactive)
      (call-interactively 'org-store-link)
      (org-capture nil "mr"))

    ;; Add custom actions for our capture templates
    (add-to-list 'mu4e-headers-actions
                 '("follow up" . my/capture-mail-follow-up) t)
    (add-to-list 'mu4e-view-actions
                 '("follow up" . my/capture-mail-follow-up) t)
    (add-to-list 'mu4e-headers-actions
                 '("read later" . my/capture-mail-read-later) t)
    (add-to-list 'mu4e-view-actions
                 '("read later" . my/capture-mail-read-later) t)

    (setq mu4e-org-contacts-file "/home/willefi/org/contacts.org")
    (add-to-list 'mu4e-headers-actions
                 '("org-contact-add" . mu4e-action-add-org-contact) t)
    (add-to-list 'mu4e-view-actions
                 '("org-contact-add" . mu4e-action-add-org-contact) t))
#+end_src
*** Mu4e contrib
#+begin_src emacs-lisp
(use-package mu4e-contrib
:straight nil)
#+end_src
** Org message
#+begin_src emacs-lisp
  (use-package org-msg
    :demand t
    :after mu4e
    :config
    (setq org-msg-options "html-postamble:nil H:5 num:nil ^:{} toc:nil author:nil email:nil \\n:t"
          org-msg-startup "hidestars indent inlineimages"
          org-msg-greeting-fmt "\nHi%s,\n\n"
          org-msg-recipient-names '(("frederic.willem@gmail.com" . "Frédéric"))
          org-msg-greeting-name-limit 3
          org-msg-default-alternatives '((new		. (text html))
                                         (reply-to-html	. (text html))
                                         (reply-to-text	. (text)))
          org-msg-convert-citation t )
    (setq org-msg-signature "\n\nRegards,\n\n\n--\n\n*Frédéric Willem*\n/Tel: +32 456 64 00 02/\n")
    (org-msg-mode))

#+end_src
** org contacts
#+begin_src emacs-lisp
  (use-package org-contacts
    :demand t
    :after org-msg
    :hook (org-msg-edit-mode . org-contacts-setup-completion-at-point)
    :custom
    (org-contacts-files '("~/org/contacts.org"))
    :config)
#+end_src
* Version control
#+begin_src emacs-lisp
  (use-package magit
    :bind (("C-x g" . magit-status)))

  (use-package git-gutter
    :init
    (global-git-gutter-mode 1)
    :config
    (setq git-gutter:update-interval 0.02))

  (use-package git-gutter-fringe
    :config
    (define-fringe-bitmap 'git-gutter-fr:added [224] nil nil '(center repeated))
    (define-fringe-bitmap 'git-gutter-fr:modified [224] nil nil '(center repeated))
    (define-fringe-bitmap 'git-gutter-fr:deleted [128 192 224 240] nil nil 'bottom))
#+end_src

* Programming
** Error checking
#+begin_src emacs-lisp
  (use-package flycheck
    :init (global-flycheck-mode))

#+end_src
** Java + Lsp
#+begin_src emacs-lisp
  ;; (use-package lsp-mode
  ;;   :init
  ;;   ;; set prefix for lsp-command-keymap (few alternatives - "C-l", "C-c l")
  ;;   (setq lsp-keymap-prefix "C-c l")
  ;;   :hook (;; replace XXX-mode with concrete major-mode(e. g. python-mode)
  ;;          (java-mode . lsp)
  ;;          ;; if you want which-key integration
  ;;          (lsp-mode . lsp-enable-which-key-integration))
  ;;   :commands lsp)

  ;; ;; optionally
  ;; (use-package lsp-ui :commands lsp-ui-mode)
  ;; (use-package lsp-treemacs :commands lsp-treemacs-errors-list)

  ;; ;; optionally if you want to use debugger
  ;; (use-package dap-mode)
  ;; (use-package lsp-java)
  ;; (use-package dap-java :straight nil)
#+end_src
* Tree-sitter
#+begin_src emacs-lisp
  (use-package tree-sitter :hook (java-mode . tree-sitter-mode))
  (use-package tree-sitter-langs)
#+end_src
* Footer
#+begin_src emacs-lisp 
  (provide 'init)
  ;; Local Variables:
  ;; byte-compile-warnings: (not free-vars)
  ;; End:
  ;;; init.el ends here (emacs-lisp-checkdoc)
#+end_src
